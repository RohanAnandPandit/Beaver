# -*- coding: utf-8 -*-
"""
Created on Tue Jun 23 09:35:26 2020

@author: rohan
"""
from Stack import Stack
from HFunction import HFunction, Lambda, Function
from Operators import Associativity, operatorFromString
from Expression import BinaryExpr
from List import Nil, Cons, Iterator
from Tuple import Tuple
from Types import Int, Collection, Alias


def printState(operands, operators):
    print("=================")
    print("OPERANDS")
    for operand in operands.arr:
        if operand == None:
            print('None')
            continue
        print(operand)
    print("=================")
    print("OPERATORS")
    for op in operators.arr:
        if op == None:
            print('None')
            continue
        print("'" + str(op) + "'")
    print("=================")
    print()

def createExpression(operators, operands):
    operator = operators.pop()
    (right, left) = (operands.pop(), operands.pop())
    if operator.name == '-':
        if left == None or isinstance(left, Collection):
            if isinstance(left, Collection):
                operands.push(left)
            left = Int(0)
    expr = BinaryExpr(operator, left, right)
    operands.push(expr)

def createCollection(operators, operands):
    operator = operators.pop()    
    right, left = operands.pop(), operands.pop()
    if isinstance(left, Collection) and left.operator.name == operator.name:
        left.items.append(right)
        expr = left
    else:
        expr = Collection([left, right], operator)
    operands.push(expr)

def addOperator(current, operands, operators):
    topOperator = operators.peek()
    # Checks if a BinaryExpr should be created using the operator on the top of the stack
    while topOperator != None:
        if (topOperator.precedence > current.precedence
            or topOperator.precedence == current.precedence 
                and topOperator.associativity == Associativity.LEFT):
            createExpression(operators, operands)
        elif current.associativity == topOperator.associativity == Associativity.NONE:
            createCollection(operators, operands)
        else:
            break
        topOperator = operators.peek()
    operators.push(current)

def pushOperand(operand, operands, operators):
        # If the top of the operands is None it will be replaced with the current value
        if operands.peek() == None:
            operands.pop()
        operands.push(operand)
        # If there are no operators means the current value is the left operand and
        # the right one is undecided yet so None is added 
        if operators.peek() == None:
            operands.push(None)  
        #print(operands.arr)

def parse(lexer):
    from utils import convertToList
    # Empty stacks will be created whenever the function is called again
    operands = Stack()
    operators = Stack()
    token = lexer.nextToken()
    while token != None:
        if isinstance(token, (HFunction, Lambda, Function)):
            # If a bracket has been opened the expression within them is generated by 
            # recursively calling the function with the same Lexer object 
            if token.name == '(':
                expr = parse(lexer)
                pushOperand(expr, operands, operators)
            elif token.name == ')':
                break
            elif token.name == '[':
                if isinstance(lexer.peek(), HFunction) and lexer.peek().name == ']':
                    lexer.nextToken()
                    pushOperand(Nil(), operands, operators)
                else:
                    if operands.peek() == None:
                        operands.pop()
                    lexer.tokens.insert(lexer.index,
                                        Collection([], operatorFromString(':')))
                    collection = parse(lexer)
                    pushOperand(convertToList(collection.items), operands, operators)
            elif token.name == '{':
                if isinstance(lexer.peek(), HFunction) and lexer.peek().name == '}':
                    lexer.nextToken()
                    pushOperand(Tuple([]), operands, operators)
                else:
                    if operands.peek() == None:
                        operands.pop() 
                    lexer.tokens.insert(lexer.index,
                                        Collection([], operatorFromString(',')))
                    collection = parse(lexer)
                    pushOperand(Tuple(collection.items), operands, operators)
            elif token.name in  ('}', ']', ','):
                # If a close bracket is reached the expression is built only 
                # using the current values on the stacks so no more tokens are used
                if operands.peek() == None:
                    operands.pop()
                # Dealing with any remaining operators
                while operators.peek() != None:
                    if operators.peek().associativity == Associativity.NONE:
                        createCollection(operators, operands)
                    else:
                        createExpression(operators, operands)

                right, left = operands.pop(), operands.pop() 
                left.items.append(right)
                operands.push(left)
                if token.name == ',':
                    lexer.tokens.insert(lexer.index,
                                        Collection([], left.operator))
                    expr = parse(lexer) 
                    operands.push(Collection(operands.pop().items + expr.items,
                                             left.operator))
                return operands.pop()
            else:
                if token.name == '`':
                    func = lexer.nextToken()
                    lexer.nextToken() == '`'
                    operands.pop() == None
                    expr = BinaryExpr(operatorFromString(' '), func, operands.pop())
                    operands.push(expr)
                    operators.push(operatorFromString(' '))
                else:
                    # Compares the current operator with the operators on the stack
                    addOperator(token, operands, operators)
        else:
            pushOperand(token, operands, operators)
        #printState(operands, operators)
        # Gets next token
        token = lexer.nextToken()
    # Dealing with any remaining operators
    while operators.peek() != None:
        if operators.peek().associativity == Associativity.NONE:
            createCollection(operators, operands)
        else:
            createExpression(operators, operands)
    result = operands.pop()
    # If the brackets contained only an operand the top of the stack would be none
    # and the actual value would be below it
    if result == None:
        result = operands.pop()   
        
    return result

            
    