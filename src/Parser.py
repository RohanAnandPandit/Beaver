# -*- coding: utf-8 -*-
"""
Created on Tue Jun 23 09:35:26 2020

@author: rohan
"""
from Stack import Stack
from HFunction import HFunction, Lambda, Function
from Operators import Associativity, operatorFromString
from Expression import BinaryExpr
from List import Nil, Array
from Tuple import Tuple
from Types import Int, Collection
    
class Parser:
    def __init__(self, lexer, program_state, infix = False):
        self.lexer = lexer
        self.infix = infix
        self.operands = Stack()
        self.operators = Stack()
        self.program_state = program_state
        self.expr = self.parse()
        
    def createExpression(self):
        operator = self.operators.pop()
        right, left = self.operands.pop(), self.operands.pop()
        expr = BinaryExpr(operator, left, right)
        self.operands.push(expr)
 
    def createCollection(self):
        operator = self.operators.pop()    
        right, left = self.operands.pop(), self.operands.pop()
        if isinstance(left, Collection) and left.operator.name==operator.name:
            left.items.append(right)
            expr = left
        else:
            if right == None and operator.name == ',':
                expr = Collection([left], operator)
            elif left == None and operator.name == ',':
                expr = Collection([right], operator)
            else: 
                expr = Collection([left, right], operator)
                
        self.pushOperand(expr)

    def addOperator(self, current):
        topOperator = self.operators.peek()
        # Checks if a BinaryExpr should be created using the operator on the 
        # top of the stack
        while topOperator != None:            
            if (topOperator.precedence == current.precedence
                  and current.associativity == topOperator.associativity == 
                  Associativity.NONE):
                self.createCollection()
                
            elif (topOperator.precedence > current.precedence
                or topOperator.precedence == current.precedence 
                    and topOperator.associativity == Associativity.LEFT):
                self.createExpression()
    
            else:
                break
            topOperator = self.operators.peek()
        self.operators.push(current)

    def pushOperand(self, operand):
            # If the top of the self.operands is None it will be replaced with
            # the current value
            if not self.operands.peek():
                self.operands.pop()
                
            if (self.operators.peek() and self.operators.peek().name == '-' and 
                not self.operands.peek()):
                self.operators.pop()
                operand = BinaryExpr(operatorFromString('*'), Int(-1),operand)
                
            self.operands.push(operand)
    
            # If there are no self.operators means the current value is the left
            # operand and the right one is undecided yet so None is added 
            if not self.operators.peek():
                self.operands.push(None)  
            #print(self.operands.arr)

    def parse(self):
        from utils import convertToList
        # Empty stacks will be created whenever the function is called again
        self.operands = Stack()
        self.operators = Stack()
        token = self.lexer.nextToken()
        while token:
            if isinstance(token, (HFunction, Lambda, Function)):
                # If a bracket has been opened the expression within them is 
                # generated by 
                # recursively calling the function with the same self.lexer 
                # object 
                if token.name == '(':
                    if (isinstance(self.lexer.peek(), HFunction) 
                        and self.lexer.peek().name == ')'):
                        self.lexer.nextToken()
                        self.pushOperand(Tuple([], self.program_state))
                    else:
                        expr = Parser(self.lexer, self.program_state).expr
                        self.pushOperand(expr)
                    
                elif token.name == ')':
                    self.remaining()
                    result = self.operands.pop()
                    if (isinstance(result, Collection) and 
                        result.operator.name == ','):
                        result = Tuple(result.items, self.program_state)
                    return result
                
                elif token.name == '[':
                    if (isinstance(self.lexer.peek(), HFunction) 
                        and self.lexer.peek().name == ']'):
                        self.lexer.nextToken()
                        self.pushOperand(Nil())
                    else:
                        expr = Parser(self.lexer, self.program_state).expr
                        self.pushOperand(expr)
    
                elif token.name == ']':
                    self.remaining()
                    result = self.operands.pop()
                    if (isinstance(result, Collection) and 
                        result.operator.name == ','):
                        result = convertToList(result.items, self.program_state)
                    else:
                        result = convertToList([result], self.program_state)
                    return result
    
                elif token.name == '{':
                    if (isinstance(self.lexer.peek(), HFunction) 
                        and self.lexer.peek().name == '}'):
                        self.lexer.nextToken()
                        self.pushOperand(Array())
                    else:
                        expr = Parser(self.lexer, self.program_state).expr
                        self.pushOperand(expr)
    
                elif token.name == '}':
                    self.remaining()
                    result = self.operands.pop()
                    if (isinstance(result, Collection) and 
                        result.operator.name == ','):
                        result = Array(result.items)
                    else:
                        result = Array([result])
                    return result
    
                elif token.name == '`':
                        if self.infix:
                            break
                        else:
                            func = Parser(self.lexer, self.program_state, 
                                          infix = True)
                            self.operands.pop() == None
                            expr = BinaryExpr(operatorFromString(' '), func,
                                              self.operands.pop())
                            self.pushOperand(expr)
                            self.operators.push(operatorFromString(' '))
                else:
                    # Compares the current operator with the self.operators on the
                    # stack
                    self.addOperator(token)
            else:
                self.pushOperand(token)
            # Gets next token
            token = self.lexer.nextToken()
        
        self.remaining()
        return self.operands.pop()

    def remaining(self):            
        # Dealing with any remaining self.operators
        while self.operators.peek() != None:
            if self.operators.peek().associativity == Associativity.NONE:
                self.createCollection()
            else:
                self.createExpression()
        
        if self.operands.peek() == None:
            self.operands.pop()  
            
    def printState(self):
        print("=================")
        print("self.operands")
        for operand in self.operands.arr:
            if operand == None:
                print('None')
                continue
            print(operand)
        print("=================")
        print("self.operators")
        for op in self.self.operators.arr:
            if op == None:
                print('None')
                continue
            print("'" + str(op) + "'")
        print("=================")
        print()