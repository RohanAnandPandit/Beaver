# -*- coding: utf-8 -*-
"""
Created on Tue Jun 23 09:35:26 2020

@author: rohan
"""
from Stack import Stack
from HFunction import HFunction, Lambda, Function
from Operators import Associativity, operatorFromString
from Expression import BinaryExpr
from List import Nil, Array
from Tuple import Tuple
from Types import Int, Collection


def printState(operands, operators):
    print("=================")
    print("OPERANDS")
    for operand in operands.arr:
        if operand == None:
            print('None')
            continue
        print(operand)
    print("=================")
    print("OPERATORS")
    for op in operators.arr:
        if op == None:
            print('None')
            continue
        print("'" + str(op) + "'")
    print("=================")
    print()

def createExpression(operators, operands):
    operator = operators.pop()
    right, left = operands.pop(), operands.pop()
    expr = BinaryExpr(operator, left, right)
    operands.push(expr)
 
def createCollection(operators, operands):
    operator = operators.pop()    
    right, left = operands.pop(), operands.pop()
    if isinstance(left, Collection) and left.operator.name == operator.name:
        left.items.append(right)
        expr = left
    else:
        if right == None and operator.name == ',':
            expr = Collection([left], operator)
        elif left == None and operator.name == ',':
            expr = Collection([right], operator)
        else:
            expr = Collection([left, right], operator)
    pushOperand(expr, operands, operators)

def addOperator(current, operands, operators):
    topOperator = operators.peek()
    # Checks if a BinaryExpr should be created using the operator on the 
    # top of the stack
    while topOperator != None:
        if (topOperator.precedence > current.precedence
            or topOperator.precedence == current.precedence 
                and topOperator.associativity == Associativity.LEFT):
            createExpression(operators, operands)
            
        elif (topOperator.precedence == current.precedence
              and current.associativity == topOperator.associativity == 
              Associativity.NONE):
            createCollection(operators, operands)
        else:
            break
        topOperator = operators.peek()
    operators.push(current)

def pushOperand(operand, operands, operators):
        # If the top of the operands is None it will be replaced with the 
        # current value
        if operands.peek() == None:
            operands.pop()
            
        if (operators.peek() != None and operators.peek().name == '-' and 
            operands.peek() == None):
            operators.pop()
            operand = BinaryExpr(operatorFromString('*'), Int(-1), operand)
            
        operands.push(operand)

        # If there are no operators means the current value is the left
        # operand and the right one is undecided yet so None is added 
        if operators.peek() == None:
            operands.push(None)  
        #print(operands.arr)

def parse(lexer, infix = False):
    from utils import convertToList
    # Empty stacks will be created whenever the function is called again
    operands = Stack()
    operators = Stack()
    token = lexer.nextToken()
    while token != None:
        if isinstance(token, (HFunction, Lambda, Function)):
            # If a bracket has been opened the expression within them is generated by 
            # recursively calling the function with the same Lexer object 
            if token.name == '(':
                if (isinstance(lexer.peek(), HFunction) 
                    and lexer.peek().name == ')'):
                    lexer.nextToken()
                    pushOperand(Tuple([]), operands, operators)
                else:
                    expr = parse(lexer)
                    pushOperand(expr, operands, operators)
                
            elif token.name == ')':
                remaining(operands, operators)
                result = operands.pop()
                if isinstance(result, Collection) and result.operator.name == ',':
                    result = Tuple(result.items)
                return result
            
            elif token.name == '[':
                if (isinstance(lexer.peek(), HFunction) 
                    and lexer.peek().name == ']'):
                    lexer.nextToken()
                    pushOperand(Nil(), operands, operators)
                else:
                    expr = parse(lexer)
                    pushOperand(expr, operands, operators)

            elif token.name == ']':
                remaining(operands, operators)
                result = operands.pop()
                if isinstance(result, Collection) and result.operator.name == ',':
                    result = convertToList(result.items)
                else:
                    result = convertToList([result])
                return result

            elif token.name == '{':
                if (isinstance(lexer.peek(), HFunction) 
                    and lexer.peek().name == '}'):
                    lexer.nextToken()
                    pushOperand(Array(), operands, operators)
                else:
                    expr = parse(lexer)
                    pushOperand(expr, operands, operators)

            elif token.name == '}':
                remaining(operands, operators)
                result = operands.pop()
                if isinstance(result, Collection) and result.operator.name == ',':
                    result = Array(result.items)
                else:
                    result = Array([result])
                return result

            elif token.name == '`':
                    if infix:
                        break
                    else:
                        func = parse(lexer, infix = True)
                        operands.pop() == None
                        expr = BinaryExpr(operatorFromString(' '), func, operands.pop())
                        pushOperand(expr, operands, operators)
                        operators.push(operatorFromString(' '))
            else:
                # Compares the current operator with the operators on the stack
                addOperator(token, operands, operators)
        else:
            pushOperand(token, operands, operators)
        # Gets next token
        token = lexer.nextToken()
    
    remaining(operands, operators)
    return operands.pop()

def remaining(operands, operators):            
    # Dealing with any remaining operators
    while operators.peek() != None:
        if operators.peek().associativity == Associativity.NONE:
            createCollection(operators, operands)
        else:
            createExpression(operators, operands)
    
    if operands.peek() == None:
        operands.pop()  