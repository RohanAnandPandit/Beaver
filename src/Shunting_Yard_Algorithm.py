# -*- coding: utf-8 -*-
"""
Created on Tue Jun 23 09:35:26 2020

@author: rohan
"""
from Stack import Stack
from HFunction import HFunction, Lambda, Function
from Operators import Associativity, operatorFromString
from Expression import UnaryExpr, BinaryExpr
from List import Nil, Cons, Iterator
from Tuple import Tuple
from Types import Int, Collection, Conditional, Else, Alias


def printState(operands, operators):
    print("=================")
    print("OPERANDS")
    for operand in operands.arr:
        if operand == None:
            print('None')
            continue
        print(operand)
    print("=================")
    print("OPERATORS")
    for op in operators.arr:
        if op == None:
            print('None')
            continue
        print("'" + str(op) + "'")
    print("=================")
    print()

def createExpression(operators, operands):
    operator = operators.pop()
    if (operator.noOfArgs == 1):
         UnaryExpr(operator, operands.pop())
    (right, left) = (operands.pop(), operands.pop())
    if operator.name == '=>':
        expr = Conditional(left, right)
    elif operator.name == '|':
        expr = Else(left, right)
    elif operator.name == '@':
        expr = Alias(left, right)    
    elif operator.name == ':':
        expr = Cons(left, right)
    elif operator.name == 'in':
        expr = Iterator(left, right)
    else:
        if operator.name == '-' and left == None:
            left = Int(0)
        expr = BinaryExpr(operator, left, right)
    operands.push(expr)

def createCollection(operators, operands):
    operator = operators.pop()    
    right, left = operands.pop(), operands.pop()
    if isinstance(left, Collection):
        if (left.operator.name == operator.name):
            left.items.append(right)
            expr = left
        else:
            expr = Collection([left, right], operator)
    else:
        expr = Collection([left, right], operator)
    operands.push(expr)

def addOperator(current, operands, operators):
    topOperator = operators.peek()
    # Checks if a BinaryExpr should be created using the operator on the top of the stack
    while topOperator != None:
        if (topOperator.precedence > current.precedence
            or topOperator.precedence == current.precedence 
                and topOperator.associativity == Associativity.LEFT):
            createExpression(operators, operands)
        elif current.associativity == topOperator.associativity == Associativity.NONE:
            createCollection(operators, operands)
        else:
            break
        topOperator = operators.peek()
    operators.push(current)

def pushOperand(operand, operands, operators):
        # If the top of the operands is None it will be replaced with the current value
        if operands.peek() == None:
            operands.pop()
        operands.push(operand)
        # If there are no operators means the current value is the left operand and
        # the right one is undecided yet so None is added 
        if operators.peek() == None:
            operands.push(None)  
        #print(operands.arr)

def convertToList(expr):
    # If None is returned means there was no operand or 
    # operator which means it is an empty list
    items = Stack()
    ops = Stack()
    for x in expr:
        items.push(x)
        ops.push(operatorFromString(':'))
    items.push(Nil())
    while ops.peek() != None:
        createExpression(ops, items)
    expr = items.pop()
    return expr

def generateExpr(parser):
    # Empty stacks will be created whenever the function is called again
    operands = Stack()
    operators = Stack()
    token = parser.nextToken()
    while token != None:
        if isinstance(token, (HFunction, Lambda, Function)):
            # If a bracket has been opened the expression within them is generated by 
            # recursively calling the function with the same Lexer object 
            if token.name == '(':
                expr = generateExpr(parser)
                pushOperand(expr, operands, operators)
            elif token.name == ')':
                break
            elif token.name == '[':
                if isinstance(parser.peek(), HFunction) and parser.peek().name == ']':
                    parser.nextToken()
                    pushOperand(Nil(), operands, operators)
                else:
                    if operands.peek() == None:
                        operands.pop()
                    parser.tokens.insert(parser.index, Collection([], operatorFromString(':')))
                    collection = generateExpr(parser)
                    pushOperand(convertToList(collection.items), operands, operators)
            elif token.name == '{':
                if isinstance(parser.peek(), HFunction) and parser.peek().name == '}':
                    parser.nextToken()
                    pushOperand(Tuple([]), operands, operators)
                else:
                    if operands.peek() == None:
                        operands.pop() 
                    parser.tokens.insert(parser.index, Collection([], operatorFromString(',')))
                    collection = generateExpr(parser)
                    pushOperand(Tuple(collection.items), operands, operators)
            elif token.name in  ('}', ']', ','):
                # If a close bracket is reached the expression is built only 
                # using the current values on the stacks so no more tokens are used
                if operands.peek() == None:
                    operands.pop()
                # Dealing with any remaining operators
                while operators.peek() != None:
                    if operators.peek().associativity == Associativity.NONE:
                        createCollection(operators, operands)
                    else:
                        createExpression(operators, operands)

                right, left = operands.pop(), operands.pop() 
                left.items.append(right)
                operands.push(left)
                if token.name in ('}', ']'):
                    return operands.pop()
                else:
                    parser.tokens.insert(parser.index, Collection([], left.operator))
                    expr = generateExpr(parser) 
                    operands.push(Collection(operands.pop().items + expr.items, left.operator))
                    return operands.pop()
            else:
                if token.name == '`':
                    token = parser.nextToken().simplify()
                    parser.nextToken()
                # Compares the current operator with the operators on the stack
                addOperator(token, operands, operators)
        else:
            pushOperand(token, operands, operators)
        #printState(operands, operators)
        # Gets next token
        token = parser.nextToken()
    # Dealing with any remaining operators
    while operators.peek() != None:
        if operators.peek().associativity == Associativity.NONE:
            createCollection(operators, operands)
        else:
            createExpression(operators, operands)
    result = operands.pop()
    # If the brackets contained only an operand the top of the stack would be none
    # and the actual value would be below it
    if result == None:
        result = operands.pop()   
        
    return result

            
    