# -*- coding: utf-8 -*-
"""
Created on Tue Jun 23 09:35:26 2020

@author: rohan
"""
from Stack import Stack
from HFunction import HFunction
from Operators import Operator, Associativity, operatorFromString
from Expression import Data, BinaryExpr
from Parser import Lexer
from List import List, Nil, Cons
from Tuple import Tuple

def printState(operands, operators):
    print("=================")
    print("OPERANDS")
    for operand in operands.arr:
        if operand == None:
            print('None')
            continue
        print(operand.toString())
    print("=================")
    print("OPERATORS")
    for op in operators.arr:
        if op == None:
            print('None')
            continue
        print("'" + op.toString() + "'")
    print("=================")
    print()

def addBinaryExpr(operators, operands):
    (right, left) = (operands.pop(), operands.pop())
    operands.push(BinaryExpr(operators.pop(), left, right))
    
def checkOperators(current, operands, operators):
    topOperator = operators.peek()
    # Checks if a BinaryExpr should be created using the operator on the top of the stack
    while (topOperator != None):
        if (topOperator.precedence > current.precedence
            or (topOperator.precedence == current.precedence 
                and topOperator.associativity == Associativity.LEFT)):
            addBinaryExpr(operators, operands)
        else:
            break
        topOperator = operators.peek()
        
    operators.push(current)

def pushOperand(operand, operands, operators):
        # If the top of the operands is None it will be replaced with the current value
        if (operands.peek() == None):
            operands.pop()
            
        operands.push(operand)
        
        # If there are no operators means the current value is the left operand and
        # the right one is undecided yet so None is added 
        if (operators.peek() == None):
            operands.push(None)    

def convertToList(expr):
    # If None is returned means there was no operand or 
    # operator which means it is an empty list
    items = Stack()
    ops = Stack()
    for x in expr:
        items.push(x)
        ops.push(Operator.COLON.value)
    items.push(Nil())
    while (ops.peek() != None):
        addBinaryExpr(ops, items)
    expr = items.pop()
        
    return List(expr)

def generateExpr(parser):
    # Empty stacks will be created whenever the function is called again
    operands = Stack()
    operators = Stack()
    returnType = 'other'
    token = parser.nextToken()
    while (token != None):
        if (isinstance(token, HFunction)):
            # If a bracket has been opened the expression within them is generated by 
            # recursively calling the function with the same Lexer object 
            if (token.name in ['(', '[']):
                (expr, internalReturnType)  = generateExpr(parser) 
                if (token.name == '['):
                    returnType = 'list'
                    if (expr == None):
                        expr = List(Nil())
                    else:
                        if (expr.operator.name in [',', '..']):
                            expr = convertToList(expr.simplify())
                        else:
                            expr = List(Cons(Data(expr), Nil()))
                else:
                    if (isinstance(expr, BinaryExpr) and expr.operator.name in [',', '..']):
                        returnType = 'tuple'
                        expr = Tuple(expr.simplify())
                    else:
                        returnType = internalReturnType
                
                pushOperand(expr, operands, operators) 
            elif (token.name in  [')', ']']):
                # If a close bracket is reached the expression is built only 
                # using the current values on the stacks so no more tokens are used
                break
            else:
                if (token.name in ['>>', '>>=', 'putChar', 'putStr', 'putStrLn', 'getLine', 'getChar']):
                    returnType = 'io'
                # Compares the current operator with the operators on the stack
                checkOperators(token, operands, operators)
        else:
            pushOperand(Data(token), operands, operators)
            
        #printState(operands, operators)
        # Gets next token
        token = parser.nextToken()
    
    # Dealing with any remaining operators
    while (operators.peek() != None):
        addBinaryExpr(operators, operands)

    result = operands.pop()
    # If the brackets contained only an operand the top of the stack would be none
    # and the actual value would be below it
    if (result == None):
        result = operands.pop()
    return (result, returnType)

            
    