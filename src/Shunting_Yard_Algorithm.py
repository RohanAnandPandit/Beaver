# -*- coding: utf-8 -*-
"""
Created on Tue Jun 23 09:35:26 2020

@author: rohan
"""
from StackQueue import StackQueue
from HFunction import HFunction
from Operators import Operator, Associativity, operatorFromString, operatorToString
from Haskell_Functions import *
from Haskell_Evaluate import operators
from Expression import Data, BinaryExpr
from Parser import Lexer

def addBinaryExpr(operators, operands):
    (right, left) = (operands.pop(), operands.pop())
    operands.push(BinaryExpr(operators.pop(), left, right))
    
def checkOperators(current, operands, operators):
    topOperator = operators.peek()
    while (topOperator != None):
        if (topOperator.precedence > current.precedence
            or (topOperator.precedence == current.precedence 
                and topOperator.associativity == Associativity.LEFT)):
            addBinaryExpr(operators, operands)
        else:
            break
        topOperator = operators.peek()
        
    operators.push(current)

def printState(operands, operators):
    print("=================")
    print("OPERANDS")
    for operand in operands.arr:
        if operand == None:
            print('None')
            continue
        print(operand.toString())
    print("=================")
    print("OPERATORS")
    for op in operators.arr:
        if op == None:
            print('None')
            continue
        print("'" + op.toString() + "'")
    print("=================")
    print()

def generateExpr(parser):
    # Empty stacks will be created whenever the function is called again
    operands = StackQueue()
    operators = StackQueue()
    
    token = parser.nextToken()
    while (token != None):
        if (isinstance(token, HFunction)):
            # If a bracket has been opened the expression within them is generated by 
            # recursively calling the function with the same Lexer object 
            if (token.name in ['(', '[']):
                expr = generateExpr(parser)                    
                if (token.name == '['):
                    if (expr == None):
                        expr = Data([])
                    elif (isinstance(expr, Data)):
                        expr = Data([expr.value])
                    else:
                        expr = BinaryExpr(Operator.SPACE.value, Operator.LIST.value, expr)
                if (operands.peek() == None):
                    operands.pop()
                operands.push(expr)
            elif (token.name in  [')', ']']):
                break
            else:
                checkOperators(token, operands, operators)
        else:
            # If the top of the operands is None it will be replaced with the current value
            if (operands.peek() == None):
                operands.pop()
                
            operands.push(Data(token))
            
            # If there are no operators means the current value is the left operand and
            # the right one is undecided yet so None is added 
            if (operators.peek() == None):
                operands.push(None)
        #printState(operands, operators)
        # Gets next token
        token = parser.nextToken()
    
    # Dealing with any remaining operators
    while (operators.peek() != None):
        addBinaryExpr(operators, operands)

    result = operands.pop()
    # If the brackets contained only an operand the top of the stack would be none
    # and the actual value would be below it
    if (result == None):
        result = operands.pop()
        
    return result    


exp = ''
while (True):
    exp = input(">>")
    if (exp == "quit"):
        break
    lexer = Lexer(exp)
    lexer.printTokens()
    print()
    binExp = generateExpr(lexer)
    print(binExp.toString())
    print("=", binExp.simplify())

            
    