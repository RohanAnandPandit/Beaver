pi = 3.1415926535
e = 2.71828182846

phi = 1.618
tau = 2pi

def sin angle = py ("sin(" ++ show angle ++ ")")

def cos angle = py ("cos(" ++ show angle ++ ")")

sqrt = (^ 0.5)

class complex (

	def init(Num real, Num imag) = (
		this.real = real
		this.imag = imag
	)
	
	def init("mod-arg", Num mod, Num arg) = (
    	init(mod * py ("cos(" ++ show arg ++ ")"),
        	 mod * py ("sin(" ++ show arg ++ ")"))
	)

    def init(Num real) = init(real, 0)
    
	def toString = (
    	if (real == imag == 0) (return "0")
    	string str = ""
		if (real != 0) (
			str = show real
			if (imag != 0) (
    			str = "(" ++ str
    			if (imag > 0) (
    				str = str ++ "+"
    			)
			)
		)
		if (imag != 0) (
    		if (imag != 1) (
        		if (imag == (-1)) (
            		str = str ++ "-"
        		) else (
            		str = str ++ show imag
            	)
        	)
            str = str ++ "i"	 
    	)
		if (real != 0 && imag != 0) (
			str = str ++ ")"
		)
		return str
		
	)

	def add (complex num) = complex(real + num.real, imag + num.imag)
	def add num = complex(real + num, imag)

	def sub (complex num) = complex(real - num.real, imag - num.imag)
	def sub (Num n) = complex(real - n, imag)

	def subfrom (complex num) = complex(num.real - real, num.imag - imag)
	def subfrom (Num n) = complex(n - real, 0-imag)
	
	def mul (complex c) = (
		complex(real * c.real - imag * c.imag,
			    real * c.imag + imag * c.real)
	)

	def mul (Num n) = complex(real * n, imag * n)
	
	def pow(int n) = (
    	var c = 1
    	for n (
        	c = c * this
        )
        return c
	)
	
	def pow(Num n) = (
		var mod = modulus
		var arg = argument
		return (complex("mod-arg", mod ^ n, arg * n))
	)

	def pow(complex num) = (
    	var a = real; var b = imag
    	var c = num.real; var d = num.imag
		var arg = argument
		var r = e ^ (0.5c * ln(a ^ 2 + b ^ 2) - d * arg)
		arg = c * arg + 0.5d * ln(a ^ 2 + b ^ 2)
		return (complex(r * cos(arg), r * sin(arg)))
	)

	def conjugate = complex (real, 0-imag)
	
	def equals(complex c) = c.real == real && c.imag == imag
	def equals(Num n) = real == n && imag == 0
	
	def modulus = sqrt(real ^ 2 + imag ^ 2)
	
	def argument = (
    	if (real == 0) (return (pi/2))
    	return (py ("atan(" ++ show (imag/real) ++ ")"))
	)
	
	def modargform = show modulus ++ "*e^(i(" ++ show argument ++ "))"
	
)

i = complex(0, 1)

fibs = iterate2 (+) 0 1 

def fib 0 = 0
def fib n = y where (int x; int y = 1; for n ((x, y) = (y, x + y)))

collatz = (takewhile (!=1))~(iterate (\x -> switch (x%2) (0=>(x/2); 1=>(3x+1))))

def ln e = 1
def ln x = py ("log(" ++ show x ++ ")")

def signum(Num n) = (
    if (n < 0) (return (-1))
    if (n > 0) (return 1)
    return 0
)

class Infinity (
    
    def init(int sign) = (
        this.sign = sign
    )
    
    def add (Num _) = Infinity(1)
    
    def subfrom (Num _) = Infinity(-sign)
    
    def greaterThan (Infinity inf) = sign > inf.sign
    def greaterThan (Num _) = sign == 1
    
    def lessThan (Num _) = sign == (-1)
    
    def mul 0 = ?
    def mul (Num n) = Infinity(sign * signum(n))
    
    def mul _ = ?
    
    def equals(Infinity inf) = inf.sign == sign
    def equals _ = False
        
    def toString = (
        string str = show (tochar 8734)
        if (sign == (-1)) (
            str = "-" ++ str
        )
        return str
    )
)
infinity = Infinity(1)