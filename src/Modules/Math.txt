pi = 3.1415926535
e = 2.71828182846

phi = 1.618
tau = 2pi

def sin angle = py ("sin(" ++ show angle ++ ")")

def cos angle = py ("cos(" ++ show angle ++ ")")

sqrt = (^ 0.5)

class Complex (

	def init(Num real, Num imag) = (
		this.real = real
		this.imag = imag
	)
	
	def init("mod-arg", Num mod, Num arg) = (
    	init(mod * py ("cos(" ++ show arg ++ ")"),
        	 mod * py ("sin(" ++ show arg ++ ")"))
	)
		
	def toString = (
    	if (real == imag == 0) (return "0")
    	string str = ""
		if (real != 0) (
			str = show real
			if (imag != 0) (
    			str = "(" ++ str
    			if (imag > 0) (
    				str = str ++ "+"
    			)
			)
		)
		if (imag != 0) (
    		if (imag != 1) (
        		if (imag == (-1)) (
            		str = str ++ "-"
        		) else (
            		str = str ++ show imag
            	)
        	)
            str = str ++ "i"	 
    	)
		if (real != 0 && imag != 0) (
			str = str ++ ")"
		)
		return str
		
	)

	def add (Complex num) = Complex(real + num.real, imag + num.imag)
	def add num = Complex(real + num, imag)

	def sub (Complex num) = Complex(real - num.real, imag - num.imag)
	def sub (Num n) = Complex(real - n, imag)

	def mul (Complex c) = (
		Complex(real * c.real - imag * c.imag,
			    real * c.imag + imag * c.real)
	)

	def mul (Num n) = Complex(real * n, imag * n)
	
	def pow(int n) = (
    	var c = 1
    	for n (
        	c *= this
        )
        return c
	)
	
	def pow(Num n) = (
		var mod = modulus
		var arg = argument
		return (Complex("mod-arg", mod ^ n, arg * n))
	)

	def pow(Complex num) = (
    	var a = real; var b = imag
    	var c = num.real; var d = num.imag
		var arg = argument
		var r = e ^ (0.5c * ln(a ^ 2 + b ^ 2) - d * arg)
		var arg = c * arg + 0.5d * ln(a ^ 2 + b ^ 2)
		return (Complex(r * cos(arg), r * sin(arg)))
	)

	def conjugate = Complex (real, 0-imag)
	
	def equals(Complex c) = c.real == real && c.imag == imag
	def equals(Num n) = real == n && imag == 0
	
	def modulus = sqrt(real ^ 2 + imag ^ 2)
	
	def argument = (
    	if (real == 0) (return (pi/2))
    	return (py ("atan(" ++ show (imag/real) ++ ")"))
	)
	
	def modargform = show modulus ++ "*e^(i(" ++ show argument ++ "))"
	
)

i = Complex(0, 1)


fact = product~(1..)

def fib 0 = 0
def fib n = y where (int x; int y = 1; for n ((x, y) = (y, x + y))) 

fibs = iterate2 (+) 0 1 

collatz = (takewhile (!= 1))~(iterate (\x -> switch (x%2) (0 => (x/2); 1 => (3x+1))))

def ln e = 1
def ln x = py ("log(" ++ show x ++ ")")
