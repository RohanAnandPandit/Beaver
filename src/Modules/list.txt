interface List (
    def head = _
    def tail = _
)

def head [] = ?
def head (x:_) = x
def tail (_:xs) = xs

def len [] = 0
def len (x:xs) = 1 + len xs 

class Take implements List (

    def init(int n, [] list) = (
        this.n = n; this.list = list
    )    
    
    def head = (
        if (n > 0) (
            x:_ = list
            return x
        )
        return ?
    ) 
    
    def tail = (
        if (n == 0) (return [])
        _:xs = list
        return (Take(n - 1, xs))
    )

    def toString = (
        if (list == []) (return "[]")
        string str = "["
        xs = list
        for (int i; i < n; i += 1) (
            x:xs = xs
            str = str ++ show x 
            if (i < n - 1) (str = str ++ ", ")
        )
        return (str ++ "]")
    )
    
    def equals xs = list == xs 
)

def take (int n) ([] xs) = Take(n, xs) 

def drop (int _) [] = []
def drop 0 xs = xs
def drop (int n) (x:xs) = drop (n - 1) xs

class Map implements List (

    def init(Func func, [] list) = (
        this.func = func; this.list = list
    )    
    
    def head = (
        x:_ = list
        return (func x)
    ) 
    
    def tail = (
        _:xs = list
        return (Map(func, xs))
    )

    def toString = (
        string str = "["
        xs = list
        while (xs != []) (
            x:xs = xs
            str = str ++ show (func x)
            if (xs != []) (
                str = str ++ ", "
            )
        )
        return (str ++ "]")
    )
    
    def equals xs = list == xs 
)

def map (Func func) ([] xs) = Map(func, xs)

def max ([] xs) = foldl max 0 xs 

def min ([] xs) = foldl min 0 xs

def sum ([] xs) = foldl (+) 0 xs

def product ([] xs) = foldl (*) 1 xs

def rev [] = []
def rev ([] xs) = rev' xs [] where (
    def rev' [] bs = bs 
    def rev' (a:as) bs = rev' as (a:bs)
)

def foldr _ u [] = u
def foldr (Func func) u (x:xs) = func x (foldr func u xs)

def foldr1 (Func func) (x:y:xs) = foldr func (func x y) xs

def foldl _ u [] = u
def foldl (Func func) u (x:xs) = foldl func (func u x) xs

def foldl1 (Func func) (x:y:xs) = foldl func (func x y) xs 

def elem x [] = False
def elem x (y:ys) = x == y || elem x ys

class TakeWhile implements List (

    def init(Func cond, [] list) = (
        this.cond = cond; this.list = list
    )    
    
    def head = (
        x:_ = list
        if (cond x) (
            return x
        )
        return ?
    ) 
    
    def tail = (
        _:xs = list
        if (not (null head)) (
             return (TakeWhile(cond, xs))
        )
        return []
    )

    def toString = (
        if (list == []) (return "[]")
        string str = "["
        x:xs = list
        while (xs != [] && cond x) (
            str = str ++ show x 
            x:xs = xs
            if (xs != [] && cond x) (str = str ++ ", ")
        )
        return (str ++ "]")
    )
    
    def equals xs = list == xs 
)

def takewhile (Func func) ([] xs) = TakeWhile(func, xs)

def dropwhile (Func _) [] = []
def dropwhile (Func func) (x:xs) = (
	if (func x) (
		return (dropwhile func xs)
	)
	return (x:xs)
)

class Filter implements List (

    def init(Func func, [] list) = (
        this.func = func; this.list = list
    )    
    
    def head = (
        x:_ = list
        if (func x) (return x)
        (x:xs) = list
        while (not (func x)) (
            if (xs == []) (return ?)
            x:xs = xs
        )
        this.list = x:xs
        return x
    ) 
    
    def tail = (
        (x:xs) = this.list
        x:xs = xs
        while (not (func x)) (
            if (xs == []) (return [])
            x:xs = xs
        )
        return (Filter(this.func, x:xs))
    )

    def equals xs = list == xs 
)

def filter (Func func) ([] xs) = Filter(func, xs)

class ZipWith implements List (

    def init(Func func, [] xs, [] ys) = (
        this.func = func; this.xs = xs; this.ys = ys
    )    
    
    def head = (
        if (xs == [] || ys == []) (
            return ?
        )
        x:_ = xs; y:_ = ys
        return (func x y)
    ) 
    
    def tail = (
        if (xs == [] || ys == []) (
            return []
        )
        _:xs' = xs; _:ys' = ys
        return (ZipWith(func, xs', ys'))
    )

    def toString = (
        string str = "["
        var xs' = xs; var ys' = ys 
        while (xs' != [] && ys' != []) (
            x:xs' = xs'; y:ys' = ys'
            str = str ++ show (func x y)
            if (xs' != [] && ys' != []) (str = str ++ ", ")
        )
        return (str ++ "]")
    )
    
    def equals xs = list == xs 
)

def zipwith (Func func) ([] xs) ([] ys) = ZipWith(func, xs, ys)

def zip ([] xs) ([] ys) = ZipWith((\x y -> (x, y)), xs, ys)

class Iterate implements List (

	def init(Func func, ? seed) = (
		this.func = func; this.seed = seed
	)

	def head = seed

	def tail = Iterate(func, (func seed))

	def toString = "[" ++ show this.seed ++ ".." ++ show func ++ " n" ++ "]"
)

def iterate (Func func) (? value) = Iterate(func, value) 


class Iterate2 implements List (

	def init(? func, first, ? second) = (
		this.first = first
		this.second = second
		this.func = func
		this.n = 0
	)
	
	def init(? func, ? first, ? second, int n) = (
		init(func, first, second)
		this.n = n
	)
	
	def head = (
        switch n (
        	0 => first
        	1 => second
        	otherwise => (func first second)
    	)
	)
	
	def tail = (
        switch n (
        	0 -> _
        	1 => Iterate2(func, first, second, n + 1)
        	otherwise => Iterate2(func, second, head, 2)
    	)
	)
	
	def toString = "iterate2 " ++ show first ++ " " ++ show second
)

def iterate2 func first second = Iterate2(func, first, second)

class Iterate3 implements List (

	def init(? func, ? first, ? second, ? third) = (
		this.first = first
		this.second = second
		this.third = third
		this.func = func
		this.n = 0
	)
	
	def init(? func, ? first, ? second, ? third, int n) = (
		init(first, second, third, func)
		this.n = n
	)
	
	def head = (
        switch n (
        	0 => first
        	1 => second
        	2 => third
        	otherwise => (func first second third)
    	)
	)
	
	def tail = (
        switch n (
        	0 -> _
        	1 -> _
        	2 -> Iterate3(func, first, second, third, n + 1)
        	otherwise => Iterate3(func, second, third, head, 3)
    	)
	)
	
	def toString = "iterate3 " ++ show first ++ " " ++ show second
)

def iterate3 func first second third = Iterate3(func, first, second, third)


class Cycle implements List (

	def init([] list, [] curr) = (
		this.list = list
		this.curr = curr
	)

	def init([] list) = (
		this.list = list
		this.curr = list
	)
	
	def head = (
		x:_ = curr
		return x
	)
	
	def tail = (
    	_:xs = curr
    	if (xs == []) (return (Cycle(list, list)))
    	return (Cycle(list, xs))
	)
	
	def toString = "cycle " ++ show this.list
)

def cycle ([] xs) = Cycle(xs)

