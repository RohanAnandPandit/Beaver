interface List (
    def head = _
    def tail = _
)

def head [] = ?
def head (x:_) = x
def tail (_:xs) = xs

def len [] = 0
def len (x:xs) = 1 + len xs 

class Take implements List (

    def init(int n, [] list) = (
        this.n = n; this.list = list
    )    
    
    def head = (
        if (n > 0) (
            x:_ = list
            return x
        )
        return ?
    )
    
    def tail = (
        if (n == 1) (return [])
        _:xs = list
        return (Take(n - 1, xs))
    )

    def toString = (
        if (list == []) (return "[]")
        string str = "["
        var xs = list
        for (int i; i < n && xs != []; i += 1) (
            x:xs = xs
            str = str ++ show x 
            if (i < n - 1) (str = str ++ ", ")
        )
        return (str ++ "]")
    )
)

def take 0 ([] _) = []
def take (int _) [] = []
def take (int n) ([] xs) = Take(n, xs)

def drop (int _) [] = []
def drop 0 xs = xs
def drop (int n) (x:xs) = drop (n - 1) xs

class Map implements List (

    def init(Func func, [] list) = (
        this.func = func; this.list = list
    )    
    
    def head = (
        x:_ = list
        return (func x)
    ) 
    
    def tail = (
        _:xs = list
        return (Map(func, xs))
    )

    def toString = (
        string str = "["
        var xs = list
        while (xs != []) (
            x:xs = xs
            str = str ++ show (func x)
            if (xs != []) (
                str = str ++ ", "
            )
        )
        return (str ++ "]")
    )
    
)

def map (Func _) [] = []
def map (Func func) ([] xs) = Map(func, xs)

def max ([] xs) = foldl max 0 xs 

def min ([] xs) = foldl min 0 xs

def sum ([] xs) = foldl (+) 0 xs

def product ([] xs) = foldl (*) 1 xs

def rev [] = []
def rev ([] xs) = rev' xs [] where (
    def rev' [] bs = bs 
    def rev' (a:as) bs = rev' as (a:bs)
)

def foldr _ u [] = u
def foldr (Func func) u (x:xs) = func x (foldr func u xs)

def foldr1 (Func func) (x:y:xs) = foldr func (func x y) xs

def foldl _ u [] = u
def foldl (Func func) u (x:xs) = foldl func (func u x) xs

def foldl1 (Func func) (x:y:xs) = foldl func (func x y) xs 

def elem x [] = False
def elem x (y:ys) = x == y || elem x ys

class TakeWhile implements List (

    def init(Func cond, [] list) = (
        this.cond = cond; this.list = list
    )    
    
    def head = (
        x:_ = list
        return x
    ) 
    
    def tail = (
        _:xs = list
        x:_ = xs
        if (not (cond x)) (
             return []
        )
        return (TakeWhile(cond, xs))
    )

    def toString = (
        if (list == []) (return "[]")
        string str = "["
        x:xs = list
        while (xs != [] && cond x) (
            str = str ++ show x 
            x:xs = xs
            if (xs != [] && cond x) (str = str ++ ", ")
        )
        return (str ++ "]")
    )
    
)

def takewhile (Func func) ([] xs) = TakeWhile(func, xs)

def dropwhile (Func _) [] = []
def dropwhile (Func func) (x:xs) = (
	if (func x) (
		return (dropwhile func xs)
	)
	return (x:xs)
)

class Filter implements List (

    def init(Func cond, [] list) = (
        this.cond = cond; this.list = list
    )    
    
    def head = (
        x:xs = list
        while (not (cond x)) (
            if (xs == []) (return ?)
            x:xs = xs
        )
        return x
    )
    
    def tail = (
        x:xs = list
        while (not (cond x)) (
            if (xs == []) (return [])
            x:xs = xs
        )
        return (Filter(cond, xs))
    )
    
    def toString = (
        if (list == []) (return "[]")
        string str = "["
        x:xs = list
        int n
        while (xs != []) (
            if (cond x) (
                if (n > 0) (
                    str = str ++ ", "
                )
                n = n + 1
                str = str ++ show x 
            )
            x:xs = xs   
        )
        return (str ++ "]")
    )
    def equals xs = list == xs 
)

def filter (Func func) ([] xs) = Filter(func, xs)

class ZipWith implements List (

    def init(Func func, [] xs, [] ys) = (
        this.func = func; this.xs = xs; this.ys = ys
    )    
    
    def head = (
        if (xs == [] || ys == []) (
            return ?
        )
        x:_ = xs; y:_ = ys
        return (func x y)
    ) 
    
    def tail = (
        if (xs == [] || ys == []) (
            return []
        )
        _:xs' = xs; _:ys' = ys
        return (zipwith func xs' ys')
    )

    def toString = (
        string str = "["
        var xs' = xs; var ys' = ys 
        while (xs' != [] && ys' != []) (
            x:xs' = xs'; y:ys' = ys'
            str = str ++ show (func x y)
            if (xs' != [] && ys' != []) (str = str ++ ", ")
        )
        return (str ++ "]")
    )
    
    def equals xs = list == xs 
)

def zipwith (Func func) ([] xs) ([] ys) = ZipWith(func, xs, ys)

def zip ([] xs) ([] ys) = ZipWith((\x y -> (x, y)), xs, ys)

class Iterate implements List (

	def init(Func func, ? seed) = (
		this.func = func; this.seed = seed
	)

	def head = seed

	def tail = iterate func (func seed)

	def toString = "[" ++ show this.seed ++ ".." ++ show func ++ " n" ++ "]"
)

def iterate (Func func) (? value) = Iterate(func, value) 


class Iterate2 implements List (

	def init(? func, ? first, ? second) = (
		this.first = first
		this.second = second
		this.func = func
		this.n = 0
	)
	
	def init(? func, ? first, ? second, int n) = (
		init(func, first, second)
		this.n = n
	)
	
	def head = (
        switch n (
        	0 => first
        	1 => second
        	otherwise => (func first second)
    	)
	)
	
	def tail = (
        switch n (
        	0 -> _
        	1 => Iterate2(func, first, second, n + 1)
        	otherwise => Iterate2(func, second, func first second, 2)
    	)
	)
	
	def toString = "iterate2 " ++ show first ++ " " ++ show second
)

def iterate2 func first second = Iterate2(func, first, second)

class Iterate3 implements List (

	def init(? func, ? first, ? second, ? third) = (
		this.first = first
		this.second = second
		this.third = third
		this.func = func
		this.n = 0
	)
	
	def init(? func, ? first, ? second, ? third, int n) = (
		init(first, second, third, func)
		this.n = n
	)
	
	def head = (
        switch n (
        	0 => first
        	1 => second
        	2 => third
        	otherwise => (func first second third)
    	)
	)
	
	def tail = (
        switch n (
        	0 -> _
        	1 -> _
        	2 -> iterate3 func first second third (n + 1)
        	otherwise => Iterate3(func, second, third, head, 3)
    	)
	)
	
	def toString = "iterate3 " ++ show first ++ " " ++ show second
)

def iterate3 func first second third = Iterate3(func, first, second, third)


class Cycle implements List (

	def init([] list, [] curr) = (
		this.list = list
		this.curr = curr
	)

	def init([] list) = (
		this.list = list
		this.curr = list
	)
	
	def head = (
		x:_ = curr
		return x
	)
	
	def tail = (
    	_:xs = curr
    	if (xs == []) (return (cycle list))
    	return (Cycle(list, xs))
	)
	
	def toString = "cycle " ++ show this.list
)

def cycle ([] xs) = Cycle(xs)


def range(start, end,  step) = (
    if (start > end) (return (takewhile (>= end) (iterate (+(-step)) start)))
    return (takewhile (<= end) (iterate (+step) start))
)

def range (first, second) (end) = range(first, end, second - first)
 
def range (start) (end) = (
    if (start < end) (
        return (takewhile (<= end) (iterate (+1) start))
    )
    return (takewhile (>= end) (iterate (+(-1)) start))
)

        
        
        
        
        
        
        
        
